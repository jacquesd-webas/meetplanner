#!/bin/sh

set -eu

# Args: environment name (e.g., development, production) and optional output paths

if [ "$#" -gt 0 ]; then
  ENVIRONMENT="$1"
  shift
else
  echo "No environment specified. Assuming 'development'."
  ENVIRONMENT="development"
fi

if [ "$ENVIRONMENT" != "development" ] && [ "$ENVIRONMENT" != "production" ] && [ "$ENVIRONMENT" != "testing" ]; then
  echo "Warning: Unrecognized environment '$ENVIRONMENT'."
  exit 1
fi

IS_CI=${CI:-} 

OUTPUT_DIRS_OR_FILES=$@

# Vars: paths

ENV_DIR="$(cd "$(dirname "$0")" && pwd)"
BASE_FILE="${ENV_DIR}/base.env"
ENV_FILE="${ENV_DIR}/${ENVIRONMENT}.env"
VARS_FILE="${ENV_DIR}/vars.list"
SECRETS_FILE="${ENV_DIR}/secrets.list"
OUTPUT_FILES=""

BASE_FRIENDLY_NAME="${BASE_FILE#"$PWD"/}"
ENV_FRIENDLY_NAME="${ENV_FILE#"$PWD"/}"

for DIRENT in $OUTPUT_DIRS_OR_FILES; do
  if echo $DIRENT | grep -q '/\.env/'; then
    # 1. Could be specifying file directly
    OUTPUT_FILES="$OUTPUT_FILES $DIRENT"
    if [ ! -d $(dirname "$DIRENT") ]; then
      echo "Warning: Output directory $(dirname "$DIRENT") does not exist; skipping."
    fi
  elif [ -d "$DIRENT" ]; then
    # 2. Could be specifying directory with full path
    OUTPUT_FILES="$OUTPUT_FILES $DIRENT/.env"
  elif [ -d "$ENV_DIR/../$DIRENT" ]; then
    # 3. Could be specifying directory relative to project root
    OUTPUT_FILES="$OUTPUT_FILES $ENV_DIR/../$DIRENT/.env"
  fi
done

if [ -z "$OUTPUT_FILES" ]; then
  # 4. Could be specifying nothing and we must find existing .env files and replace them
  EXIST_ENV_FILES=$(find "$ENV_DIR/../" -maxdepth 2 -type f -name ".env" -name "*.env*" 2>/dev/null || true)
  if [ -n "$EXIST_ENV_FILES" ]; then
    OUTPUT_FILES="$EXIST_ENV_FILES"
  else
    echo "Warning: No .env files found. If this is the first time please specify which directories to generate .env files into."
  fi
fi


PWD="$(pwd)"
# Functions

warn_mismatch() {
  file="$1"
  warning=0
  while IFS= read -r raw || [ -n "$raw" ]; do
    line="${raw%%#*}"
    line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$line" ] && continue
    key="${line%%=*}"
    [ -z "$key" ] && continue
    if ! grep -qx "$key" "$BASE_KEYS_TMP"; then
      echo "Warning: key '${key}' in ${file##*/} not present in base.env" >&2
      warning=1
    fi
  done < "$file"
  return $warning
}

append_list() {
  file="$1"
  while IFS= read -r raw || [ -n "$raw" ]; do
    line="${raw%%#*}"
    line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$line" ] && continue

    target="$line"
    source="$line"

    case "$line" in
      *=*)
        target="${line%%=*}"
        source="${line#*=}"
        ;;
    esac

    value="$(eval "printf '%s' \"\${$source-}\"")"
    if [ -z "$value" ]; then
      if [ -z "$IS_CI" ] || [ "$IS_CI" != "true" ]; then
       printf '#%s=%s\n' "$target" "$value"
      else
        echo "Warning: Variable '$source' not set while in CI pipeline; skipping." >&2
        printf '#%s=%s\n' "$target" "$value"
      fi
    else
      printf '%s=%s\n' "$target" "$value"
    fi
  done < "$file"
}

dedup() {
  local file="$1"
  if [ ! -f "$file" ]; then
    echo "File not found: $file" >&2
    return 1
  fi

  awk '
    { lines[NR] = $0 }
    END {
      for (i = NR; i >= 1; i--) {
        line = lines[i]
        if (line ~ /^[[:space:]]*#/ || line !~ /=/) { keep[i] = 1; continue }
        key = line
        sub(/^[[:space:]]*/, "", key)
        sub(/[[:space:]]*=.*/, "", key)
        if (!(key in seen)) { seen[key] = 1; keep[i] = 1 }
      }
      for (i = 1; i <= NR; i++) if (keep[i]) print lines[i]
    }
  ' "$file"
}

# 1. Locate all required files

for file in "$BASE_FILE" "$VARS_FILE" "$SECRETS_FILE"; do
  if [ ! -f "$file" ]; then
    echo "Missing required file: $file" >&2
    exit 1
  fi
done

BASE_KEYS_TMP="$(mktemp)"
trap 'rm -f "$BASE_KEYS_TMP"' EXIT

# 2. Extract base keys

while IFS= read -r raw || [ -n "$raw" ]; do
  line="${raw%%#*}"
  line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
  [ -z "$line" ] && continue
  key="${line%%=*}"
  [ -z "$key" ] && continue
  echo "$key" >> "$BASE_KEYS_TMP"
done < "$BASE_FILE"


for FILE in "$ENV_FILE" "$VARS_FILE" "$SECRETS_FILE"; do
  warnings=0
  # strip the $PWD from the path for clearer output
  FRIENDLY_NAME="${FILE#"$PWD"/}"
  if [ ! -f "$FILE" ]; then
    echo "Warning: $FRIENDLY_NAME not found, skipping mismatch check." >&2
    continue
  fi
  warn_mismatch "$FILE" || warnings=1
done

# 3. Generate tmp output file
OUTPUT_FILE_TMP=$(mktemp)
trap 'rm -f "$OUTPUT_FILE_TMP"' EXIT

printf "## This file was automatically generated by make-env.sh\n" > "$OUTPUT_FILE_TMP"
printf "## Base environment from ${BASE_FILE##*/}\n" >> "$OUTPUT_FILE_TMP"
cat $BASE_FILE >> "$OUTPUT_FILE_TMP"

if [ -f "$ENV_FILE" ]; then
  printf "\n## Overrides from ${ENV_FILE##*/}\n" >> "$OUTPUT_FILE_TMP"
  cat "$ENV_FILE" >> "$OUTPUT_FILE_TMP"
fi

printf "\n## Override from CI/CD vars\n" >> "$OUTPUT_FILE_TMP"
append_list "$VARS_FILE" >> "$OUTPUT_FILE_TMP"

printf "\n## Override from CI/CD secrets\n" >> "$OUTPUT_FILE_TMP"
append_list "$SECRETS_FILE" >> "$OUTPUT_FILE_TMP"

for OUTPUT_FILE in $OUTPUT_FILES; do
  dedup "$OUTPUT_FILE_TMP" > "$OUTPUT_FILE"
  echo "Wrote ${OUTPUT_FILE} for ${ENVIRONMENT}"
done



